from __future__ import annotations

from typing import Any, Dict, Generator, List, Optional, Tuple, TypedDict, Union
from typing_extensions import Literal

from pydantic import BaseModel
from pydantic import Extra, Field, conlist, schema_of
from pydantic.annotated_types import create_model_from_typeddict
from pydantic.class_validators import root_validator
from pydantic.tools import schema_of


##################################################
# General                                        #
##################################################

Domain = Tuple[float, float]


class OverlayOptions(BaseModel):
    extent: Optional[List] = None
    minWidth: Optional[float] = None
    fill: Optional[str] = None
    fillOpacity: Optional[float] = None
    stroke: Optional[str] = None
    strokeOpacity: Optional[float] = None
    strokeWidth: Optional[float] = None
    strokePos: Optional[Union[str, List[Any]]] = None
    outline: Optional[str] = None
    outlineOpacity: Optional[float] = None
    outlineWidth: Optional[float] = None
    outlinePos: Optional[Union[str, List[Any]]] = None


class Overlay(BaseModel):
    class Config:
        extra = Extra.forbid

    type: Optional[str] = None
    uid: Optional[str] = None
    chromInfoPath: Optional[str] = None
    includes: Optional[List] = None
    options: Optional[OverlayOptions] = None


##################################################
# Locks                                          #
##################################################


# Locks are tricky to describe with python's type system
# because _some_ keys are static (e.g., the lock `uid`) while
# the rest of the keys are dynamic (the view uids) and
# satisfy a different type constraint.
#
# In JSON schema, this is type can be described using an "object"
# "type" with "additionalProperties" or "patternProperties" field.
#
# ```json
# {
#   "type": "object",
#   "properties": {
#     "uid": { "type: "string" },
#   },
#   "additionalProperties": {
#     "type": "object",
#     "minLength": 3,
#     "maxLength": 3,
#     "items": { "type": "number" }
#   }
# }
# ```
#
# The lock classes implement pydantic Models which:
#
# (1) Performs the appropriate validation/serde for this object
#
# (2) Exports the appropriate JSON schema using "additionalProperties"
#     field via a custom `schema_extra` extension.
#
# This could probably be implemented generally with
# pydantic.generics.Generic/typing.Generic, but we implement
# concretely for the different lock types.


def simplify_schema(root_schema: Dict[str, Any]) -> Dict[str, Any]:
    if not "$ref" in root_schema or len(root_schema["definitions"]) > 1:
        return root_schema
    # lift definitions to root if only one definiton
    defs = list(root_schema["definitions"].values())
    assert len(defs) == 1
    return defs[0]


def set_additional_properties_with_type(type_: Any):
    """Overrides json schema 'additionalProperties' with schema for `type_`"""

    def schema_extra(schema: Dict[str, Any], _) -> None:
        lock_schema = schema_of(type_)
        lock_schema = simplify_schema(lock_schema)
        # remove autogenerated title
        lock_schema.pop("title")
        # make sure we aren't overriding anything on subclass
        assert "additionalProperties" not in schema
        schema["additionalProperties"] = lock_schema

    return staticmethod(schema_extra)


LockEntry = Tuple[float, float, float]

# We'd rather have tuples in our final model, because a
# __root__ model is clunky from an end user perspective.
# We create this class to get validation for free in
# `root_validator`
class _LockEntryModel(BaseModel):
    __root__: LockEntry


class Lock(BaseModel):
    uid: Optional[str] = None

    class Config:
        extra = Extra.allow
        schema_extra = set_additional_properties_with_type(LockEntry)

    def __iter__(self) -> Generator[Tuple[str, LockEntry], None, None]:
        for key, val in super().__iter__():
            if key not in self.__fields__:
                yield key, val

    # can only validate on creation for "extra" fields
    @root_validator(pre=True)
    def validate_locks(cls, values: Dict[str, Any]):
        for k in values:
            if k not in cls.__fields__:
                # validate using our custom validator
                model = _LockEntryModel.parse_obj(values[k])
                # get back the root type
                values[k] = model.__root__
        return values


class ValueScaleLockEntry(TypedDict):
    view: str
    track: str


_ValueScaleLockEntryModel = create_model_from_typeddict(ValueScaleLockEntry)  # type: ignore


class ValueScaleLock(BaseModel):
    uid: Optional[str] = None
    ignoreOffScreenValues: Optional[bool] = None

    class Config:
        extra = Extra.allow
        schema_extra = set_additional_properties_with_type(ValueScaleLockEntry)

    def __iter__(self) -> Generator[Tuple[str, ValueScaleLockEntry], None, None]:
        for key, val in super().__iter__():
            if key not in self.__fields__:
                yield key, val

    # can only validate on creation for "extra" fields
    @root_validator(pre=True)
    def validate_locks(cls, values: Dict[str, Any]):
        for k in values:
            if k not in cls.__fields__:
                # validate using our custom validator
                model = _ValueScaleLockEntryModel.parse_obj(values[k])
                # read back as a regular dict
                values[k] = model.dict()
        return values


class AxisSpecificLocks(BaseModel):
    class Config:
        extra = Extra.forbid

    axis: Literal["x", "y"]
    lock: str


class LocationLocks(BaseModel):
    class Config:
        extra = Extra.forbid

    locksByViewUid: Dict[str, Union[str, AxisSpecificLocks]] = {}
    locksDict: Dict[str, Lock] = {}


class ZoomLocks(BaseModel):
    class Config:
        extra = Extra.forbid

    locksByViewUid: Dict[str, str] = {}
    locksDict: Dict[str, Lock] = {}


class ValueScaleLocks(BaseModel):
    class Config:
        extra = Extra.forbid

    locksByViewUid: Dict[str, str] = {}
    locksDict: Dict[str, ValueScaleLock] = {}


##################################################
# Tracks                                         #
##################################################

TrackOptions = Dict[str, Any]
TilesetInfo = Dict[str, Any]
Tile = Dict[str, Any]


class Data(BaseModel):
    type: Optional[str] = None
    url: Optional[str] = None
    server: Optional[str] = None
    filetype: Optional[str] = None
    children: Optional[List] = None
    tilesetInfo: Optional[TilesetInfo] = None
    tiles: Optional[Tile] = None


class BaseTrack(BaseModel):
    class Config:
        extra = Extra.forbid

    uid: Optional[str] = None
    width: Optional[int] = None
    height: Optional[int] = None
    options: Optional[TrackOptions] = None


class Tileset(BaseModel):
    class Config:
        extra = Extra.forbid

    tilesetUid: Optional[str] = None
    server: Optional[str] = None


ViewportProjectionTrackType = Literal[
    "viewport-projection-center",
    "viewport-projection-vertical",
    "viewport-projection-horizontal",
]

EnumTrackType = Union[
    ViewportProjectionTrackType,
    Literal[
        "multivec",
        "1d-heatmap",
        "line",
        "point",
        "bar",
        "divergent-bar",
        "stacked-interval",
        "gene-annotations",
        "linear-2d-rectangle-domains",
        "chromosome-labels",
        "linear-heatmap",
        "1d-value-interval",
        "2d-annotations",
        "2d-chromosome-annotations",
        "2d-chromosome-grid",
        "2d-chromosome-labels",
        "2d-rectangle-domains",
        "2d-tiles",
        "arrowhead-domains",
        "bedlike",
        "cross-rule",
        "dummy",
        "horizontal-1d-annotations",
        "horizontal-1d-heatmap",
        "horizontal-1d-tiles",
        "horizontal-1d-value-interval",
        "horizontal-2d-rectangle-domains",
        "horizontal-bar",
        "horizontal-chromosome-grid",
        "horizontal-chromosome-labels",
        "horizontal-divergent-bar",
        "horizontal-gene-annotations",
        "horizontal-heatmap",
        "horizontal-line",
        "horizontal-multivec",
        "horizontal-point",
        "horizontal-rule",
        "horizontal-vector-heatmap",
        "image-tiles",
        "left-axis",
        "left-stacked-interval",
        "mapbox-tiles",
        "osm-2d-tile-ids",
        "osm-tiles",
        "raster-tiles",
        "simple-svg",
        "square-markers",
        "top-axis",
        "top-stacked-interval",
        "vertical-1d-annotations",
        "vertical-1d-heatmap",
        "vertical-1d-tiles",
        "vertical-1d-value-interval",
        "vertical-2d-rectangle-domains",
        "vertical-bar",
        "vertical-bedlike",
        "vertical-chromosome-grid",
        "vertical-chromosome-labels",
        "vertical-gene-annotations",
        "vertical-heatmap",
        "vertical-line",
        "vertical-multivec",
        "vertical-point",
        "vertical-rule",
        "vertical-vector-heatmap",
    ],
]


class EnumTrack(BaseTrack, Tileset):
    type: EnumTrackType
    data: Optional[Data] = None
    chromInfoPath: Optional[str] = None
    fromViewUid: Optional[str] = None
    x: Optional[float] = None
    y: Optional[float] = None


class HeatmapTrack(BaseTrack, Tileset):
    type: Literal["heatmap"]
    data: Optional[Data] = None
    position: Optional[str] = None
    transforms: Optional[List] = None


class IndependentViewportProjectionTrack(BaseTrack):
    type: ViewportProjectionTrackType
    fromViewUid: None = None
    projectionXDomain: Optional[Domain] = None
    projectionYDomain: Optional[Domain] = None
    transforms: Optional[List] = None
    x: Optional[float] = None
    y: Optional[float] = None


class CombinedTrack(BaseTrack):
    type: Literal["combined"]
    contents: List[Track]
    position: Optional[str] = None


Track = Union[
    EnumTrack,
    CombinedTrack,
    HeatmapTrack,
    IndependentViewportProjectionTrack,
]

# CombinedTrack is recursive and needs delayed evaluation of annoations
CombinedTrack.update_forward_refs()


##################################################
# View                                           #
##################################################


class Tracks(BaseModel):
    class Config:
        extra = Extra.forbid

    left: Optional[List[Track]] = None
    right: Optional[List[Track]] = None
    top: Optional[List[Track]] = None
    bottom: Optional[List[Track]] = None
    center: Optional[List[Track]] = None
    whole: Optional[List[Track]] = None
    gallery: Optional[List[Track]] = None


class Layout(BaseModel):
    class Config:
        extra = Extra.forbid

    x: int = Field(default=0, title="The X Position")
    y: int = Field(default=0, title="The Y Position")
    w: int = Field(default=12, title="Width")
    h: int = Field(default=12, title="Height")
    moved: Optional[bool] = None
    static: Optional[bool] = None


class GenomePositionSearchBox(BaseModel):
    autocompleteServer: Optional[str] = Field(
        default=None,
        examples=["//higlass.io/api/v1"],
        title="The Autocomplete Server URL",
    )
    autocompleteId: Optional[str] = Field(
        default=None,
        examples=["OHJakQICQD6gTD7skx4EWA"],
        title="The Autocomplete ID",
    )
    chromInfoServer: str = Field(
        ...,
        examples=["//higlass.io/api/v1"],
        title="The Chrominfo Server URL",
    )
    chromInfoId: str = Field(..., examples=["hg19"], title="The Chromosome Info ID")
    visible: Optional[bool] = Field(False, title="The Visible Schema")


class View(BaseModel):
    class Config:
        extra = Extra.forbid

    layout: Layout
    tracks: Tracks
    uid: Optional[str] = None
    autocompleteSource: Optional[str] = None
    chromInfoPath: Optional[str] = None
    genomePositionSearchBox: Optional[GenomePositionSearchBox] = None
    genomePositionSearchBoxVisible: Optional[bool] = None
    initialXDomain: Optional[Domain] = None
    initialYDomain: Optional[Domain] = None
    overlays: Optional[List[Overlay]] = None
    selectionView: Optional[bool] = None
    zoomFixed: Optional[bool] = None
    zoomLimits: Tuple[float, Optional[float]] = (1, None)


##################################################
# Viewconf                                       #
##################################################


class Viewconf(BaseModel):
    class Config:
        extra = Extra.forbid

    editable: Optional[bool] = True
    viewEditable: Optional[bool] = True
    tracksEditable: Optional[bool] = True
    zoomFixed: Optional[bool] = None
    compactLayout: Optional[bool] = None
    exportViewUrl: Optional[str] = None
    trackSourceServers: Optional[conlist(str, min_items=1)] = None
    zoomLocks: Optional[ZoomLocks] = None
    locationLocks: Optional[LocationLocks] = None
    valueScaleLocks: Optional[ValueScaleLocks] = None
    views: Optional[conlist(View, min_items=1)] = None
    chromInfoPath: Optional[str] = None


if __name__ == "__main__":
    try:
        from rich import print_json
    except ImportError:
        print_json = print

    print_json(Viewconf.schema_json())
